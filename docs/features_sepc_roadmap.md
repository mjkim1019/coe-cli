# Swing CLI 기능 명세서

Swing CLI 기능 명세서 (Architect 모드 통합 개편안)

본 문서는 Swing CLI의 기능과 설계 방향을 Architect 모드 중심으로 재구성한 개편안입니다. 기존 기능 명세의 핵심 요소를 유지하되 자연어 중심의 플로우와 에이전트 기반 오케스트레이션을 포함하도록 확장했습니다.

## 0. 핵심 개념

Architect 모드 – /architect "기능 요청" 하나만으로 Plan 생성 → 편집 실행 → 테스트 → 적용까지 전체 오케스트레이션을 자동 수행합니다. 사용자는 자연어로 목표를 입력하고, LLM이 /edit, /exec, /repair 등 필요한 명령을 추천합니다.

대화형 REPL – /ask, /edit, /architect 등 명령어 기반 인터페이스와 자동완성 기능을 제공하며, LLM이 코드 구조를 분석하고 자연어 요약을 제공합니다. 파일 타입별 특화 분석(C, XML, SQL)을 지원합니다.

자동 세션 저장 – 실행마다 생성되는 plan.yaml, 단계별 diff, 테스트 로그가 세션 단위로 저장됩니다. /resume 명령으로 언제든 이전 세션을 복원하여 이어서 수행할 수 있습니다.

AGENTS.md 자동 생성 – coe init 시 프로젝트 컨텍스트를 정리한 AGENTS.md 템플릿을 생성합니다. 도메인, 스택, 도구, 제약 사항 등을 기록하여 에이전트가 프로젝트를 이해하는 데 활용됩니다.

## 1. 사용자 흐름 (Text‑to‑SQL 예시)

아래는 Architect 모드에서 텍스트를 SQL 쿼리로 변환하는 흐름의 예시입니다.

``` bash
coe init
  # .coe/ 디렉터리 생성 및 AGENTS.md 템플릿 자동 생성
/architect "유선 회선 기준으로 유무선 결합 가입년수 합산값 조회하는 쿼리 개발해줘"
  # 자연어 요청 → Plan 작성 → 단계별 편집/실행 제안
  # (LLM) ➜ "아래 명령을 제안합니다: /edit, /exec"
  # 사용자는 제안된 명령을 accept 여부만 결정
  # (자동) ➜ plan.yaml 생성, 신규 SQL 파일 생성
  # (자동) ➜ 모든 세션은 저장되어 resume 가능
/resume
  # 이전 세션 이어서 진행 (선택적)
/ask "<테이블명> 테이블은 왜 필요한거야?"
  # 보조 도구로 자유 질의
```
## 2. P0 완료 기능

아래 기능들은 P0 범주에 해당하며 현재 구현되어 있습니다. Architect 모드에서도 그대로 활용됩니다.

### 기능	설명
LLM 기반 코드 구조 분석	– 계층 구조, 호출 관계, 파일 카테고리화 및 자연어 요약을 제공하고, C/XML/SQL 전용 프롬프트로 심화 분석을 수행합니다.
대화형 CLI (REPL)	– prompt_toolkit 기반 명령어 인터페이스와 자동완성 기능을 갖춘 CLI로 /add, /ask, /edit, /test 등을 지원합니다.
파일 타입별 특화 분석 – 	C 파일(.c), XML 파일(.xml), SQL 파일(.sql) 전용 프롬프트를 사용하여 각 타입에 특화된 정보를 분석합니다.
템플릿 기반 신규 파일 생성 – 미리 정의된 템플릿으로 새로운 파일을 자동 생성합니다
온디맨드 분석 및 캐싱	– /add 시 기본 분석만 수행하고, 사용자가 구조 분석을 요청하면 CoeAnalyzer로 심화 분석을 실행하며 결과를 캐싱합니다.
JSON 응답 처리 및 디버그 정보 출력 –	LLM 응답을 JSON으로 강제하여 테이블로 보여주고, 호출 과정을 상세히 로깅하여 투명성을 확보합니다.


## 3. 기능 우선순위 (P1/P2/P3)

### P1 – 2025년 Q4 목표

튜토리얼 모드 – 처음 사용자를 위한 대화형 가이드 제공. C/SQL/XML 파일 분석 실습을 포함합니다.

Text to SQL 기능 - 자연어를 입력받아 SQL 문을 개발하는 기능을 제공합니다.

Plan & Execute 기능 – LLM이 복잡한 요청을 단계별로 분해하여 계획하고, 사용자에게 어떤 작업을 실행할지 알려주고 허락 받아 실행합니다.

AGENTS.md Rule 파일 생성 – 프로젝트 전반에서 참조할 AGENTS.md 문서를 자동 생성하는 기능.


### P2 – 2026년 Q1 목표

프롬프트 캐싱 – OpenAI 프롬프트를 캐시에 저장하여 반복 호출 시 성능을 최적화합니다.

Model Context Protocol (MCP) – 표준화된 컨텍스트 프로토콜로 여러 LLM 모델 간 일관된 통신을 제공합니다.

파일 감시 (Hot Reload) – 파일 시스템 변경을 감지하여 자동으로 재분석을 수행합니다.

Edit GuardRail – 파일 변경 이력을 추적하고 LLM이 생성한 변경 이유를 주석으로 남겨 롤백 가능하도록 합니다.

세션 이어서 하기 – 컨텍스트 저장/복구를 강화하여 장기 작업에서 세션 연속성을 제공합니다.

### P3 (부가 기능) – 2026년 Q2 목표

자동 테스트 – 파일 저장/수정 시 Makefile/CMake 기반 테스트를 자동으로 실행합니다.

정교한 diff/patch – 변경 사항 분석, 패치 적용, 롤백, 백업 기능을 개선합니다.

세션 관리 – 세션 저장/복구, LLM 기반 자동 컨텍스트 구성을 포함합니다.


## 4. 파일 타입별 특화 분석 시스템

기존 명세서에서 정의한 C/XML/SQL 파일 분석 대상과 표준 함수 구조 자동 인식, Oracle SQL 특징 자동 분석 등은 그대로 유지됩니다. 일반 파일에 대해서는 주석을 중심으로 목적을 추출하고 함수와 의존성, 입출력 파라미터의 nullable 정보를 분석합니다.

## 5. 특수 용어 인식

사용자가 DBIO(Database Input/Output) 등 특정 용어를 언급할 때에는 자동으로 관련 컨텍스트를 활성화하여 SQL 쿼리 작성, 데이터베이스 연결 및 트랜잭션 처리, 성능 튜닝 등과 같은 주제를 보다 정확하게 지원합니다.

## 6. 주요 명령어

Swing CLI에서 사용할 수 있는 명령어를 현재 구현된 명령어와 개발 예정 명령어로 구분하여 정리합니다.

### 6.1 현재 구현된 명령어
```
명령어	설명
/add <파일>	파일을 컨텍스트에 추가하여 분석 대상에 포함합니다.
/ask	질문 모드로, 코드 구조나 특정 로직에 대해 질의할 때 사용합니다.
/edit	수정 모드로 진입하며, 전체 파일 수정, 특정 블록 수정 또는 udiff 기반 수정이 가능합니다.
/test	현재 컨텍스트에 추가된 파일에 대해 테스트를 실행합니다.
/preview	LLM이 생성한 변경사항을 적용하기 전에 미리보기로 확인합니다.
/apply	미리보기로 확인한 변경사항을 실제 파일에 적용합니다.
/help	사용 가능한 명령어 목록과 도움말을 표시합니다.
/exit	CLI 세션을 종료합니다.
/repo	현재 작업 중인 디렉터리의 파일 구조를 분석하여 보여줍니다.
```
### 6.2 개발 예정 명령어
```
명령어	설명
/architect plan & execute 모드를 시작합니다
/tutorial	처음 사용자를 위한 대화형 튜토리얼 모드를 시작합니다.
/watch <디렉터리>	지정한 디렉터리를 감시하여 파일 변경 시 자동으로 분석·테스트를 실행합니다.
coe test	명령줄에서 직접 테스트를 실행합니다.
coe diff	변경된 파일들의 차이(diff)를 확인합니다.
coe patch	생성된 패치를 적용합니다.
coe revert	변경 사항을 롤백합니다.
coe save-session	현재 세션을 저장합니다.
coe resume	저장된 세션을 불러와 이어서 작업합니다.
coe web	파일 트리와 그래프를 시각화하는 웹 UI를 실행합니다.
/continue	이전 세션을 이어서 시작합니다.
```

---

## 별첨1. 파일 타입별 특화 분석 시스템 ✅

### C 파일 (.c) - IO Formatter 중심 분석
C 파일 전용 프롬프트로 다음 요소들을 중점 분석합니다:

**핵심 분석 대상:**
- **IO Formatter**: 입출력 구조체 분석
- **c000_main_proc**: 메인 프로세스 로직 분석
- **DBIO 호출 패턴**: 어떤 DBIO 함수를 호출하여 출력을 생성하는지 분석

**표준 함수 구조 자동 인식:**
- `a000_init_proc`: 프로그램 초기화 함수
- `b000_input_validation`: 입력 데이터 검증 수행
- `c000_main_proc`: 실제 프로그램의 주요 로직 처리
- `z999_err_exit_proc`: 프로그램 에러 종료 처리

### XML 파일 (.xml) - TrxCode 중심 분석
XML 파일 전용 프롬프트로 다음 요소들을 중점 분석합니다:

**핵심 분석 대상:**
- **TrxCode 호출 패턴**: 어떤 TrxCode를 호출하고 있는지 분석
- **TrxCode 함수 바디**: TrxCode가 있는 함수를 중점적으로 분석
- **UI 컴포넌트**: 그리드, 입력필드, 버튼, 데이터셋 분석
- **JavaScript 함수**: scwin.xxx 형태의 함수 분석
- **데이터 흐름**: 입력 필드와 출력 결과의 매핑 관계

### SQL 파일 (.sql) - 입출력 및 테이블 조인 중심 분석
SQL 파일 전용 프롬프트로 다음 요소들을 중점 분석합니다:

**핵심 분석 대상:**
- **입출력 값 분석**: 바인드 변수(:variable)와 SELECT 결과 컬럼의 nullable 여부
- **테이블 조인 관계**: 어떤 테이블을 조인하고 있는지와 조인 목적 분석
- **Oracle 특화 기능**: 힌트, 함수, (+) 조인 등 사용 패턴 분석
- **성능 최적화**: 쿼리 복잡도와 최적화 제안사항

**Oracle SQL 특징 자동 분석:**
- **오라클 힌트**: `/*+ index(...) use_nl(...) */` 등의 성능 최적화 힌트
- **바인드 변수**: `:svc_mgmt_num`, `:bas_dt` 등의 파라미터 및 nullable 정보
- **아우터 조인**: Oracle 전용 `(+)` 구문
- **오라클 함수**: NVL, TO_CHAR, SYSDATE 등
- **특수 날짜 패턴**: `99991231235959`, `99991231` 등의 무한대 날짜 패턴

### 일반 파일 (기타) - 기본 분석
기타 파일 타입에 대해서는 일반적인 코드 분석을 수행합니다:
- 파일 목적 (주석 우선 추출)
- 주요 함수 및 의존성 분석
- 입출력 파라미터의 nullable 정보 포함

---

## 별첨2. 특수 용어 인식

### DBIO (Database Input/Output)
사용자가 "dbio"에 대해 질문할 때 자동으로 데이터베이스 입출력 관련 컨텍스트로 인식합니다:
- SQL 쿼리 작성 및 최적화
- 데이터베이스 연결 및 트랜잭션 처리
- 데이터 입출력 로직 분석
- 성능 튜닝 관련 질문

---

## 별첨3. 향후 기능 상세 설명


### 튜토리얼 모드 (개발 예정)

**목적**: 처음 사용하는 사용자가 실제 파일로 Swing CLI의 주요 기능을 체험할 수 있는 대화형 가이드

**기능**:
- `test_with_fixtures.py` 기반의 실습 시나리오
- C, SQL, XML 파일별 특화 분석 실습
- 단계별 Enter 키를 통한 진행/스킵 가능
- 실제 `tests/fixtures/` 파일들을 사용한 체험

**튜토리얼 단계**:
1. **파일 추가 체험**: `ORDSS04S2050T01.c`, `ZORDSS0340082.XML`, `zord_svc_prod_grp_s0001.sql` 파일 추가
2. **C 파일 분석**: IO Formatter 패턴, 함수 구조, DBIO 호출 분석
3. **XML 파일 분석**: TrxCode 패턴, UI 컴포넌트, JavaScript 함수 분석
4. **SQL 파일 분석**: 바인드 변수, 테이블 조인, Oracle 힌트 분석
5. **질문/편집 실습**: Ask/Edit 모드로 실제 코드 분석 및 수정

### 프롬프트 캐싱 (개발 예정)

**목적**: OpenAI API 프롬프트 캐싱을 활용한 성능 최적화 및 비용 절감

**기능**:
- 반복적으로 사용되는 시스템 프롬프트 캐싱
- 파일별 특화 분석 프롬프트 캐싱 (C/SQL/XML)
- 컨텍스트 프롬프트 자동 캐싱
- 캐시 히트율 모니터링 및 통계

**구현 방식**:
```python
# 예시 구현
class PromptCacheManager:
    def cache_system_prompt(self, file_type: str, prompt: str):
        """파일 타입별 시스템 프롬프트 캐싱"""

    def get_cached_prompt(self, cache_key: str):
        """캐싱된 프롬프트 반환"""

    def invalidate_cache(self, pattern: str):
        """캐시 무효화"""
```

### 파일 감시 기능 (개발 예정)

**목적**: 파일 시스템 변경을 실시간으로 감지하고 자동으로 재분석 수행

**기능**:
- `watchdog` 라이브러리 기반 파일 시스템 감시
- 지정된 디렉토리의 .c, .sql, .xml 파일 변경 감지
- 변경 감지 시 자동 재분석 및 컨텍스트 업데이트
- Hot Reload 방식의 실시간 분석 결과 반영

**명령어**:
```bash
> /watch ./src                    # ./src 디렉토리 감시 시작
> /watch stop                     # 감시 중지
> /watch status                   # 감시 상태 확인
```

**구현 방식**:
```python
# 예시 구현
class FileWatcher:
    def start_watching(self, directory: str, extensions: List[str]):
        """파일 감시 시작"""

    def on_file_modified(self, event):
        """파일 변경 이벤트 핸들러"""
        # 자동 재분석 수행
        # 컨텍스트 업데이트
        # 사용자에게 알림
```

### Edit GuardRail (개발 예정)

**목적**: 파일 변경 이력을 체계적으로 추적하고 변경 이유를 자동으로 문서화

**기능**:
- 모든 파일 편집에 대한 메타데이터 기록
- LLM이 변경 이유를 자동으로 생성하여 주석으로 삽입
- 누가(사용자), 언제(타임스탬프), 어디를(파일:라인), 왜(LLM 생성 이유) 변경했는지 추적
- Git 스타일의 blame 기능과 연동

**주석 형태**:
```c
// [SWING-CLI] 2024-01-15 14:30:25 by user123
// [변경이유] 입력 검증 로직 강화를 위해 NULL 체크 추가
if (input_data == NULL) {
    return ERROR_INVALID_INPUT;
}
```

**구현 방식**:
```python
class EditGuardRail:
    def log_change(self, file_path: str, line_range: tuple,
                   change_reason: str, user: str):
        """변경 이력 기록"""

    def generate_change_comment(self, old_code: str, new_code: str) -> str:
        """LLM을 통한 변경 이유 생성"""

    def insert_change_metadata(self, file_path: str, line_num: int,
                              metadata: str):
        """파일에 변경 메타데이터 주석 삽입"""
```

---

- **P1**: 11주 (2024년 Q4 ~ 2025년 Q1)
- **P2**: 8주 (2026년 Q1)
- **P3**: 10주 (2026년 Q2 ~ Q3)
- **총 개발 기간**: 약 15개월 (2025년 7월 ~ 2026년 9월)
